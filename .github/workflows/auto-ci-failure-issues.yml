name: üö® Auto-cr√©ation d'issues pour √©checs CI/CD

on:
  workflow_run:
    workflows:
      - "Test sur master"
      - "üèóÔ∏è Module CI/CD"
      - "Code Quality"
      - "üöÄ Module Deployment"
      - "Semantic Release"
    types:
      - completed

jobs:
  create-failure-issue:
    runs-on: ubuntu-latest
    if: ${{ github.event.workflow_run.conclusion == 'failure' }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Get workflow details
        id: workflow-details
        uses: actions/github-script@v7
        with:
          script: |
            const workflowRun = context.payload.workflow_run;

            // Mapper les noms de workflows vers les types
            const workflowTypeMap = {
              'Test sur master': 'üß™ Tests (tests-on-master)',
              'üèóÔ∏è Module CI/CD': 'üèóÔ∏è CI Module (module-ci)',
              'Code Quality': 'üîç Qualit√© de code (code-quality)',
              'üöÄ Module Deployment': 'üöÄ D√©ploiement (module-deployment)',
              'Semantic Release': 'üì¶ Release (release)'
            };

            // D√©terminer le type d'√©chec bas√© sur le nom du workflow
            let failureType = 'Autre';
            const workflowName = workflowRun.name;

            if (workflowName.includes('Test') || workflowName.includes('CI')) {
              failureType = '‚ùå Tests unitaires en √©chec';
            } else if (workflowName.includes('Quality')) {
              failureType = 'üîç √âchec de qualit√© de code (Pint, PHPStan)';
            } else if (workflowName.includes('Deployment')) {
              failureType = 'üöÄ √âchec de d√©ploiement';
            } else if (workflowName.includes('Release')) {
              failureType = 'üì¶ √âchec de build/compilation';
            }

            // D√©terminer l'urgence bas√©e sur la branche
            let urgency = 'üü° Moyenne - Impact limit√©';
            if (workflowRun.head_branch === 'master' || workflowRun.head_branch === 'main') {
              urgency = 'üî¥ Critique - Bloque la production';
            } else if (workflowRun.head_branch === 'develop') {
              urgency = 'üü† Haute - Bloque le d√©veloppement';
            }

            // Analyser les modules affect√©s bas√©s sur les fichiers modifi√©s
            let affectedModules = ['Aucun module sp√©cifique'];

            // Si c'est un workflow de module, essayer de d√©tecter le module
            if (workflowName.includes('Module')) {
              // Cette logique pourrait √™tre am√©lior√©e en analysant les fichiers modifi√©s
              affectedModules = ['Tous les modules'];
            }

            return {
              workflowType: workflowTypeMap[workflowName] || 'Autre workflow',
              failureType: failureType,
              urgency: urgency,
              affectedModules: affectedModules,
              workflowUrl: workflowRun.html_url,
              commitSha: workflowRun.head_sha.substring(0, 8),
              branch: workflowRun.head_branch
            };

      - name: Get workflow logs
        id: get-logs
        uses: actions/github-script@v7
        with:
          script: |
            const workflowRun = context.payload.workflow_run;

            try {
              // R√©cup√©rer les jobs du workflow
              const jobs = await github.rest.actions.listJobsForWorkflowRun({
                owner: context.repo.owner,
                repo: context.repo.repo,
                run_id: workflowRun.id
              });

              let errorDetails = '';

              // Trouver les jobs en √©chec
              const failedJobs = jobs.data.jobs.filter(job => job.conclusion === 'failure');

              if (failedJobs.length > 0) {
                errorDetails = `## Jobs en √©chec:\n\n`;

                for (const job of failedJobs.slice(0, 3)) { // Limiter √† 3 jobs pour √©viter un texte trop long
                  errorDetails += `### ${job.name}\n`;
                  errorDetails += `- **Statut**: ${job.conclusion}\n`;
                  errorDetails += `- **Dur√©e**: ${Math.round((new Date(job.completed_at) - new Date(job.started_at)) / 1000)}s\n`;

                  // R√©cup√©rer les logs du job (limit√© car l'API peut √™tre volumineuse)
                  try {
                    const logs = await github.rest.actions.downloadJobLogsForWorkflowRun({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      job_id: job.id
                    });

                    // Note: Les logs sont en format binaire, on ne peut pas les traiter directement ici
                    errorDetails += `- **Logs**: [Voir les logs complets](${job.html_url})\n\n`;
                  } catch (error) {
                    errorDetails += `- **Logs**: [Voir les logs complets](${job.html_url})\n\n`;
                  }
                }
              } else {
                errorDetails = `Workflow en √©chec: ${workflowRun.name}\n\nVoir les d√©tails complets: ${workflowRun.html_url}`;
              }

              return errorDetails;
            } catch (error) {
              return `Erreur lors de la r√©cup√©ration des logs: ${error.message}\n\nVoir le workflow: ${workflowRun.html_url}`;
            }

      - name: Check for existing issue
        id: check-existing
        uses: actions/github-script@v7
        with:
          script: |
            const workflowRun = context.payload.workflow_run;
            const searchQuery = `repo:${context.repo.owner}/${context.repo.repo} is:issue is:open label:ci "[CI] √âchec sur ${workflowRun.name}"`;

            const issues = await github.rest.search.issuesAndPullRequests({
              q: searchQuery
            });

            // V√©rifier s'il y a une issue r√©cente (moins de 24h) pour le m√™me workflow
            const recentIssues = issues.data.items.filter(issue => {
              const createdAt = new Date(issue.created_at);
              const now = new Date();
              const hoursDiff = (now - createdAt) / (1000 * 60 * 60);
              return hoursDiff < 24;
            });

            return recentIssues.length > 0;

      - name: Create CI failure issue
        if: steps.check-existing.outputs.result == 'false'
        uses: actions/github-script@v7
        with:
          script: |
            const workflowRun = context.payload.workflow_run;
            const details = ${{ steps.workflow-details.outputs.result }};
            const errorLogs = `${{ steps.get-logs.outputs.result }}`;

            // Cr√©er le corps de l'issue en format qui sera trait√© par le template
            const issueBody = `
            **Type de workflow en √©chec**: ${details.workflowType}
            **Branche concern√©e**: ${details.branch}
            **Commit SHA**: ${details.commitSha}
            **ID du workflow**: ${details.workflowUrl}
            **Type d'√©chec**: ${details.failureType}
            **Niveau d'urgence**: ${details.urgency}
            **Modules affect√©s**: ${details.affectedModules.join(', ')}

            ## D√©tails de l'erreur

            ${errorLogs}

            ## Informations du workflow

            - **Workflow**: ${workflowRun.name}
            - **Run ID**: ${workflowRun.id}
            - **Branche**: ${workflowRun.head_branch}
            - **Commit**: ${workflowRun.head_sha}
            - **Auteur**: ${workflowRun.actor.login}
            - **√âv√©nement**: ${workflowRun.event}
            - **Heure d'√©chec**: ${workflowRun.updated_at}

            ## Actions automatiques effectu√©es

            - ‚úÖ Issue cr√©√©e automatiquement
            - üîç Logs du workflow analys√©s
            - üè∑Ô∏è Labels appropri√©s ajout√©s
            - üë§ Assignation automatique effectu√©e

            ## √âtapes de r√©solution sugg√©r√©es

            1. üîç Analyser les logs d√©taill√©s du workflow
            2. üß™ Reproduire l'erreur localement
            3. üìã V√©rifier les changements r√©cents (git diff)
            4. üîß V√©rifier la configuration des environnements
            5. üì¶ V√©rifier les d√©pendances et versions

            ---
            *Issue cr√©√©e automatiquement par le workflow d'automatisation CI/CD*
            `;

            // Cr√©er l'issue
            const issue = await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `[CI] √âchec sur ${workflowRun.name} - ${details.branch} (${details.commitSha})`,
              body: issueBody,
              labels: ['bug', 'ci', 'urgent'],
              assignees: ['vortechstudio']
            });

            console.log(`Issue cr√©√©e: ${issue.data.html_url}`);
            return issue.data.number;

      - name: Add workflow run comment
        if: steps.check-existing.outputs.result == 'false'
        uses: actions/github-script@v7
        with:
          script: |
            const issueNumber = ${{ steps.create-failure-issue.outputs.result }};
            const workflowRun = context.payload.workflow_run;

            if (issueNumber) {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNumber,
                body: `üîó **Lien direct vers le workflow en √©chec**: ${workflowRun.html_url}\n\n` +
                      `üìä **Statistiques du run**:\n` +
                      `- Dur√©e: ${Math.round((new Date(workflowRun.updated_at) - new Date(workflowRun.created_at)) / 1000)}s\n` +
                      `- Tentative: ${workflowRun.run_attempt}\n` +
                      `- ID: ${workflowRun.id}`
              });
            }

      - name: Notify on Slack (if configured)
        if: steps.check-existing.outputs.result == 'false' && vars.SLACK_WEBHOOK_URL
        uses: actions/github-script@v7
        with:
          script: |
            const workflowRun = context.payload.workflow_run;
            const details = ${{ steps.workflow-details.outputs.result }};
            const issueNumber = ${{ steps.create-failure-issue.outputs.result }};

            const slackMessage = {
              text: `üö® √âchec CI/CD d√©tect√©`,
              blocks: [
                {
                  type: "header",
                  text: {
                    type: "plain_text",
                    text: "üö® √âchec CI/CD d√©tect√©"
                  }
                },
                {
                  type: "section",
                  fields: [
                    {
                      type: "mrkdwn",
                      text: `*Workflow:* ${workflowRun.name}`
                    },
                    {
                      type: "mrkdwn",
                      text: `*Branche:* ${details.branch}`
                    },
                    {
                      type: "mrkdwn",
                      text: `*Commit:* ${details.commitSha}`
                    },
                    {
                      type: "mrkdwn",
                      text: `*Urgence:* ${details.urgency}`
                    }
                  ]
                },
                {
                  type: "actions",
                  elements: [
                    {
                      type: "button",
                      text: {
                        type: "plain_text",
                        text: "Voir le workflow"
                      },
                      url: workflowRun.html_url
                    },
                    {
                      type: "button",
                      text: {
                        type: "plain_text",
                        text: "Voir l'issue"
                      },
                      url: `https://github.com/${context.repo.owner}/${context.repo.repo}/issues/${issueNumber}`
                    }
                  ]
                }
              ]
            };

            // Envoyer √† Slack (n√©cessite la configuration de SLACK_WEBHOOK)
            if (process.env.SLACK_WEBHOOK) {
              await fetch(process.env.SLACK_WEBHOOK, {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                },
                body: JSON.stringify(slackMessage)
              });
            }
        env:
          SLACK_WEBHOOK: ${{ secrets.SLACK_WEBHOOK }}

  update-existing-issue:
    runs-on: ubuntu-latest
    if: ${{ github.event.workflow_run.conclusion == 'failure' }}

    steps:
      - name: Find and update existing issue
        uses: actions/github-script@v7
        with:
          script: |
            const workflowRun = context.payload.workflow_run;
            const searchQuery = `repo:${context.repo.owner}/${context.repo.repo} is:issue is:open label:ci "${workflowRun.name}"`;

            const issues = await github.rest.search.issuesAndPullRequests({
              q: searchQuery
            });

            if (issues.data.items.length > 0) {
              const issue = issues.data.items[0];

              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                body: `üîÑ **Nouvel √©chec d√©tect√©**\n\n` +
                      `- **Workflow**: ${workflowRun.name}\n` +
                      `- **Branche**: ${workflowRun.head_branch}\n` +
                      `- **Commit**: ${workflowRun.head_sha.substring(0, 8)}\n` +
                      `- **Heure**: ${workflowRun.updated_at}\n` +
                      `- **Lien**: ${workflowRun.html_url}\n\n` +
                      `*Le probl√®me persiste. Veuillez v√©rifier les corrections pr√©c√©dentes.*`
              });

              // Ajouter le label "recurring" si ce n'est pas d√©j√† fait
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                labels: ['recurring']
              });

              console.log(`Issue existante mise √† jour: ${issue.html_url}`);
            }
