name: üöÄ Deploy

on:
  # D√©clenchement automatique apr√®s la completion r√©ussie des workflows critiques


  # D√©clenchement manuel pour les d√©ploiements d'urgence ou sp√©cifiques
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - production
      skip_validations:
        description: 'Skip pre-deployment validations (emergency only)'
        required: false
        default: false
        type: boolean
      deployment_type:
        description: 'Type of deployment'
        required: false
        default: 'standard'
        type: choice
        options:
          - standard
          - hotfix
          - rollback
      force_deploy:
        description: 'Force deployment even if workflows failed (emergency only)'
        required: false
        default: false
        type: boolean

env:
  PHP_VERSION: '8.3'
  NODE_VERSION: '20'
  SLACK_WEBHOOK: ${{ secrets.SLACK_WEBHOOK }}

permissions:
  issues: write
  pull-requests: write
  contents: write

jobs:
  # ============================================================================
  # PRE-DEPLOYMENT VALIDATIONS
  # ============================================================================
  pre-deployment-checks:
    name: üîç Pre-deployment validations
    runs-on: ubuntu-latest
    if: |
      (github.event.inputs.skip_validations != 'true') &&
      (github.event_name == 'workflow_dispatch' ||
       github.event.workflow_run.conclusion == 'success' ||
       github.event.inputs.force_deploy == 'true')
    outputs:
      tests-passed: ${{ steps.check-tests.outputs.passed }}
      quality-passed: ${{ steps.check-quality.outputs.passed }}
      security-passed: ${{ steps.check-security.outputs.passed }}
      deployment-approved: ${{ steps.final-check.outputs.approved }}
    steps:
      - name: üìã Workflow trigger information
        run: |
          echo "üöÄ Informations sur le d√©clenchement du d√©ploiement"
          echo "Event name: ${{ github.event_name }}"

          if [[ "${{ github.event_name }}" == "workflow_run" ]]; then
            echo "D√©clench√© par le workflow: ${{ github.event.workflow_run.name }}"
            echo "Statut du workflow d√©clencheur: ${{ github.event.workflow_run.conclusion }}"
            echo "Branche: ${{ github.event.workflow_run.head_branch }}"
            echo "Commit: ${{ github.event.workflow_run.head_sha }}"

            # V√©rifier que le workflow d√©clencheur a r√©ussi
            if [[ "${{ github.event.workflow_run.conclusion }}" != "success" ]]; then
              echo "‚ùå Le workflow d√©clencheur a √©chou√© - Arr√™t du d√©ploiement"
              echo "Pour forcer le d√©ploiement malgr√© l'√©chec, utilisez le d√©clenchement manuel avec 'force_deploy: true'"
              exit 1
            fi
          elif [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "D√©clenchement manuel"
            echo "Environnement cible: ${{ github.event.inputs.environment }}"
            echo "Type de d√©ploiement: ${{ github.event.inputs.deployment_type }}"
            echo "Skip validations: ${{ github.event.inputs.skip_validations }}"
            echo "Force deploy: ${{ github.event.inputs.force_deploy }}"
          fi

          echo "Branche actuelle: ${{ github.ref_name }}"
          echo "Commit actuel: ${{ github.sha }}"

      - name: üì• Checkout code
        uses: actions/checkout@v5

      - name: üîç Verify all critical workflows status
        if: github.event_name == 'workflow_run'
        run: |
          echo "üîç V√©rification du statut de tous les workflows critiques..."

          # Liste des workflows critiques
          CRITICAL_WORKFLOWS=(
            "üèóÔ∏è Module CI/CD"
            "üìä Code Metrics & Quality Gate"
            "üîí Security Deep Scan"
          )

          BRANCH="${{ github.event.workflow_run.head_branch }}"
          ALL_SUCCESS=true

          for workflow in "${CRITICAL_WORKFLOWS[@]}"; do
            echo "V√©rification du workflow: $workflow"

            # Obtenir le statut du dernier run de ce workflow sur la branche
            LATEST_RUN=$(gh run list --workflow="$workflow" --branch="$BRANCH" --limit=1 --json status,conclusion --jq '.[0]')

            if [[ "$LATEST_RUN" == "null" || "$LATEST_RUN" == "" ]]; then
              echo "‚ö†Ô∏è Aucun run trouv√© pour le workflow: $workflow"
              ALL_SUCCESS=false
              continue
            fi

            STATUS=$(echo $LATEST_RUN | jq -r '.status')
            CONCLUSION=$(echo $LATEST_RUN | jq -r '.conclusion')

            echo "  Status: $STATUS, Conclusion: $CONCLUSION"

            if [[ "$STATUS" != "completed" || "$CONCLUSION" != "success" ]]; then
              echo "‚ùå Workflow √©chou√© ou incomplet: $workflow"
              ALL_SUCCESS=false
            else
              echo "‚úÖ Workflow r√©ussi: $workflow"
            fi
          done

          if [[ "$ALL_SUCCESS" != "true" ]]; then
            echo ""
            echo "‚ùå Certains workflows critiques ont √©chou√© ou sont incomplets"
            echo "Le d√©ploiement ne peut pas continuer automatiquement"
            echo "Pour forcer le d√©ploiement, utilisez le d√©clenchement manuel avec 'force_deploy: true'"
            exit 1
          else
            echo ""
            echo "‚úÖ Tous les workflows critiques ont r√©ussi - D√©ploiement autoris√©"
          fi
        env:
          GH_TOKEN: ${{ github.token }}

      - name: üîç Check latest CI status
        id: check-tests
        run: |
          echo "üîç V√©rification du statut des tests CI..."
          # V√©rifier le statut du dernier workflow module-ci
          LATEST_RUN=$(gh run list --workflow=module-ci.yml --limit=1 --json status,conclusion --jq '.[0]')
          STATUS=$(echo $LATEST_RUN | jq -r '.status')
          CONCLUSION=$(echo $LATEST_RUN | jq -r '.conclusion')

          if [[ "$STATUS" == "completed" && "$CONCLUSION" == "success" ]]; then
            echo "‚úÖ Tests CI pass√©s avec succ√®s"
            echo "passed=true" >> $GITHUB_OUTPUT
          else
            echo "‚ùå Tests CI √©chou√©s ou en cours"
            echo "passed=false" >> $GITHUB_OUTPUT
          fi
        env:
          GH_TOKEN: ${{ github.token }}

      - name: üéØ Check quality gate status
        id: check-quality
        run: |
          echo "üéØ V√©rification du quality gate..."
          # V√©rifier le statut du dernier workflow code-metrics
          LATEST_RUN=$(gh run list --workflow=code-metrics.yml --limit=1 --json status,conclusion --jq '.[0]')
          STATUS=$(echo $LATEST_RUN | jq -r '.status')
          CONCLUSION=$(echo $LATEST_RUN | jq -r '.conclusion')

          if [[ "$STATUS" == "completed" && "$CONCLUSION" == "success" ]]; then
            echo "‚úÖ Quality gate valid√©"
            echo "passed=true" >> $GITHUB_OUTPUT
          else
            echo "‚ùå Quality gate non valid√©"
            echo "passed=false" >> $GITHUB_OUTPUT
          fi
        env:
          GH_TOKEN: ${{ github.token }}

      - name: üîí Check security scan status
        id: check-security
        run: |
          echo "üîí V√©rification des scans de s√©curit√©..."
          # V√©rifier le statut du dernier workflow security
          LATEST_RUN=$(gh run list --workflow=security.yml --limit=1 --json status,conclusion --jq '.[0]')
          STATUS=$(echo $LATEST_RUN | jq -r '.status')
          CONCLUSION=$(echo $LATEST_RUN | jq -r '.conclusion')

          if [[ "$STATUS" == "completed" && "$CONCLUSION" == "success" ]]; then
            echo "‚úÖ Scans de s√©curit√© valid√©s"
            echo "passed=true" >> $GITHUB_OUTPUT
          else
            echo "‚ùå Scans de s√©curit√© √©chou√©s"
            echo "passed=false" >> $GITHUB_OUTPUT
          fi
        env:
          GH_TOKEN: ${{ github.token }}

      - name: ‚úÖ Final deployment approval
        id: final-check
        run: |
          TESTS_PASSED="${{ steps.check-tests.outputs.passed }}"
          QUALITY_PASSED="${{ steps.check-quality.outputs.passed }}"
          SECURITY_PASSED="${{ steps.check-security.outputs.passed }}"

          if [[ "$TESTS_PASSED" == "true" && "$QUALITY_PASSED" == "true" && "$SECURITY_PASSED" == "true" ]]; then
            echo "‚úÖ Toutes les validations sont pass√©es - D√©ploiement approuv√©"
            echo "approved=true" >> $GITHUB_OUTPUT
          else
            echo "‚ùå Certaines validations ont √©chou√© - D√©ploiement bloqu√©"
            echo "approved=false" >> $GITHUB_OUTPUT
            exit 1
          fi

  # ============================================================================
  # STAGING DEPLOYMENT (SSH)
  # ============================================================================
  deploy-staging:
    name: üöÄ Deploy to Staging (SSH)
    runs-on: ubuntu-latest
    if: |
      (
        (github.event_name == 'workflow_run' && github.event.workflow_run.head_branch == 'master') ||
        (github.event_name == 'workflow_dispatch' && github.event.inputs.environment == 'staging') ||
        (github.ref == 'refs/heads/master')
      ) &&
      (
        needs.pre-deployment-checks.outputs.deployment-approved == 'true' ||
        github.event.inputs.skip_validations == 'true' ||
        github.event.inputs.force_deploy == 'true'
      )
    needs: [pre-deployment-checks]
    environment:
      name: staging
      url: ${{ steps.deploy.outputs.staging-url }}
    outputs:
      deployment-id: ${{ steps.deploy.outputs.deployment-id }}
      staging-url: ${{ steps.deploy.outputs.staging-url }}
    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v5

      - name: üêò Setup PHP
        uses: shivammathur/setup-php@v2
        with:
          php-version: ${{ env.PHP_VERSION }}
          extensions: dom, curl, libxml, mbstring, zip, pcntl, pdo, sqlite, pdo_sqlite, bcmath, soap, intl, gd, exif, iconv, imagick
          coverage: none

      - name: üì¶ Cache Composer dependencies
        uses: actions/cache@v4
        with:
          path: vendor
          key: composer-${{ runner.os }}-${{ hashFiles('composer.lock') }}
          restore-keys: composer-${{ runner.os }}-

      - name: üì¶ Install Composer dependencies
        run: composer install --optimize-autoloader --no-interaction --prefer-dist

      - name: üü¢ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: üì¶ Install npm dependencies
        run: npm ci

      - name: üèóÔ∏è Build assets for staging
        run: |
          npm run build
          echo "‚úÖ Assets built successfully"

      - name: üîß Prepare deployment package
        run: |
          echo "üîß Pr√©paration du package de d√©ploiement..."

          # Cr√©er un dossier temporaire pour le d√©ploiement
          mkdir -p deployment-package

          # Copier les fichiers n√©cessaires (exclure les dossiers inutiles)
          rsync -av --exclude='node_modules' \
                    --exclude='.git' \
                    --exclude='tests' \
                    --exclude='storage/logs/*' \
                    --exclude='storage/framework/cache/*' \
                    --exclude='storage/framework/sessions/*' \
                    --exclude='storage/framework/views/*' \
                    --exclude='.env.example' \
                    --exclude='deployment-package' \
                    . deployment-package/

          # Cr√©er une archive pour le transfert
          tar -czf batistack-staging.tar.gz -C deployment-package .
          echo "üì¶ Package de d√©ploiement cr√©√© : batistack-staging.tar.gz"

      - name: üîë Setup SSH key
        run: |
          echo "üîë Configuration de la cl√© SSH..."
          mkdir -p ~/.ssh
          echo "${{ secrets.STAGING_SSH_PRIVATE_KEY }}" > ~/.ssh/staging_key
          chmod 600 ~/.ssh/staging_key

          # Ajouter le serveur aux known_hosts (remplacez par votre IP/domaine)
          ssh-keyscan -H ${{ secrets.STAGING_HOST }} >> ~/.ssh/known_hosts

      - name: üöÄ Deploy to staging server
        id: deploy
        run: |
          echo "üöÄ D√©ploiement vers le serveur de staging..."

          # Variables de configuration (√† adapter selon votre serveur)
          STAGING_HOST="${{ secrets.STAGING_HOST }}"
          STAGING_USER="${{ secrets.STAGING_USER }}"
          STAGING_PATH="${{ secrets.STAGING_PATH }}"  # Ex: /var/www/batistack-staging
          STAGING_URL="${{ secrets.STAGING_URL }}"    # Ex: https://staging.batistack.com
          DEPLOYMENT_ID="staging-$(date +%s)"

          echo "üì° Connexion au serveur staging : $STAGING_USER@$STAGING_HOST"

          # Transf√©rer le package
          echo "üì§ Transfert du package..."
          scp -i ~/.ssh/staging_key batistack-staging.tar.gz $STAGING_USER@$STAGING_HOST:/tmp/

          # Ex√©cuter le d√©ploiement sur le serveur distant
          ssh -i ~/.ssh/staging_key $STAGING_USER@$STAGING_HOST << 'EOF'
            set -e
            echo "üîÑ D√©ploiement en cours sur le serveur staging..."

            # Variables locales
            STAGING_PATH="${{ secrets.STAGING_PATH }}"
            BACKUP_PATH="/tmp/batistack-backup-$(date +%s)"

            # Cr√©er une sauvegarde de l'ancienne version
            if [ -d "$STAGING_PATH" ]; then
              echo "üíæ Sauvegarde de l'ancienne version..."
              cp -r "$STAGING_PATH" "$BACKUP_PATH"
            fi

            # Cr√©er le dossier de staging s'il n'existe pas
            mkdir -p "$STAGING_PATH"

            # Extraire le nouveau package
            echo "üì¶ Extraction du package..."
            cd "$STAGING_PATH"
            tar -xzf /tmp/batistack-staging.tar.gz

            # Restaurer les dossiers de storage persistants
            if [ -d "$BACKUP_PATH/storage/app" ]; then
              cp -r "$BACKUP_PATH/storage/app" storage/
            fi
            if [ -d "$BACKUP_PATH/storage/logs" ]; then
              cp -r "$BACKUP_PATH/storage/logs" storage/
            fi

            # Copier le fichier .env sp√©cifique au staging
            if [ -f ".env.staging" ]; then
              echo '${{ secrets.STAGING_ENV }}' > .env
              echo "üìÑ Fichier .env staging configur√©"
            else
              echo "‚ö†Ô∏è Fichier .env.staging non trouv√©, utilisation de .env.example"
              echo '${{ secrets.STAGING_ENV }}' > .env
              # G√©n√©rer une nouvelle cl√© d'application
              php artisan key:generate --force
            fi

            # Installation des d√©pendances Composer
            echo "üì¶ Installation des d√©pendances..."
            composer install --no-dev --optimize-autoloader --no-interaction

            # Migrations et cache
            echo "üóÑÔ∏è Migration de la base de donn√©es..."
            php artisan migrate --force

            echo "üßπ Nettoyage et reconstruction du cache..."
            php artisan cache:clear
            php artisan config:clear
            php artisan route:clear
            php artisan view:clear

            php artisan config:cache
            php artisan route:cache
            php artisan view:cache

            # Optimisations
            php artisan optimize
            composer dump-autoload --optimize

            # Permissions (adaptez selon votre serveur web)
            echo "üîê Configuration des permissions..."
            chown -R www-data:www-data storage bootstrap/cache
            chmod -R 775 storage bootstrap/cache

            # Nettoyage
            rm -f /tmp/batistack-staging.tar.gz

            echo "‚úÖ D√©ploiement staging termin√© avec succ√®s"
          EOF

          echo "üåê URL de staging : $STAGING_URL"
          echo "deployment-id=$DEPLOYMENT_ID" >> $GITHUB_OUTPUT
          echo "staging-url=$STAGING_URL" >> $GITHUB_OUTPUT

      - name: üß™ Post-deployment health check
        run: |
          echo "üß™ V√©rification de la sant√© de l'application..."
          STAGING_URL="${{ steps.deploy.outputs.staging-url }}"

          # Attendre quelques secondes pour que le serveur se stabilise
          sleep 10

          # Test de connectivit√©
          if curl -f -s --max-time 30 "$STAGING_URL" > /dev/null; then
            echo "‚úÖ Application staging op√©rationnelle"
            echo "üìä Test de sant√© r√©ussi pour : $STAGING_URL"
          else
            echo "‚ùå Erreur lors du test de sant√©"
            echo "üîç V√©rifiez manuellement l'URL : $STAGING_URL"
            exit 1
          fi

      - name: üßπ Cleanup SSH
        if: always()
        run: |
          echo "üßπ Nettoyage des cl√©s SSH..."
          rm -f ~/.ssh/staging_key
          rm -f batistack-staging.tar.gz

  # ============================================================================
  # PRODUCTION DEPLOYMENT (SSH)
  # ============================================================================
  deploy-production:
    name: üöÄ Deploy to Production (SSH)
    runs-on: ubuntu-latest
    if: |
      (
        (github.event_name == 'workflow_run' && github.event.workflow_run.head_branch == 'production') ||
        (github.event_name == 'workflow_dispatch' && github.event.inputs.environment == 'production') ||
        (github.ref == 'refs/heads/production')
      ) &&
      (
        needs.pre-deployment-checks.outputs.deployment-approved == 'true' ||
        github.event.inputs.skip_validations == 'true' ||
        github.event.inputs.force_deploy == 'true'
      )
    needs: [pre-deployment-checks]
    environment:
      name: production
      url: ${{ steps.deploy.outputs.production-url }}
    outputs:
      deployment-id: ${{ steps.deploy.outputs.deployment-id }}
      production-url: ${{ steps.deploy.outputs.production-url }}
    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v5

      - name: üêò Setup PHP
        uses: shivammathur/setup-php@v2
        with:
          php-version: ${{ env.PHP_VERSION }}
          extensions: dom, curl, libxml, mbstring, zip, pcntl, pdo, sqlite, pdo_sqlite, bcmath, soap, intl, gd, exif, iconv, imagick
          coverage: none

      - name: üì¶ Cache Composer dependencies
        uses: actions/cache@v4
        with:
          path: vendor
          key: composer-${{ runner.os }}-${{ hashFiles('composer.lock') }}
          restore-keys: composer-${{ runner.os }}-

      - name: üì¶ Install Composer dependencies
        run: composer install --no-dev --optimize-autoloader --no-interaction --prefer-dist

      - name: üü¢ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: üì¶ Install npm dependencies
        run: npm ci

      - name: üèóÔ∏è Build assets for production
        run: |
          npm run build
          echo "‚úÖ Assets built successfully"

      - name: üîß Prepare deployment package
        run: |
          echo "üîß Pr√©paration du package de d√©ploiement production..."

          # Cr√©er un dossier temporaire pour le d√©ploiement
          mkdir -p deployment-package

          # Copier les fichiers n√©cessaires (exclure les dossiers inutiles)
          rsync -av --exclude='node_modules' \
                    --exclude='.git' \
                    --exclude='tests' \
                    --exclude='storage/logs/*' \
                    --exclude='storage/framework/cache/*' \
                    --exclude='storage/framework/sessions/*' \
                    --exclude='storage/framework/views/*' \
                    --exclude='.env.example' \
                    --exclude='deployment-package' \
                    . deployment-package/

          # Cr√©er une archive pour le transfert
          tar -czf batistack-production.tar.gz -C deployment-package .
          echo "üì¶ Package de d√©ploiement production cr√©√© : batistack-production.tar.gz"

      - name: üîë Setup SSH key for production
        run: |
          echo "üîë Configuration de la cl√© SSH production..."
          mkdir -p ~/.ssh
          echo "${{ secrets.PRODUCTION_SSH_PRIVATE_KEY }}" > ~/.ssh/production_key
          chmod 600 ~/.ssh/production_key

          # Ajouter le serveur aux known_hosts
          ssh-keyscan -H ${{ secrets.PRODUCTION_HOST }} >> ~/.ssh/known_hosts

      - name: üöÄ Deploy to production server
        id: deploy
        run: |
          echo "üöÄ D√©ploiement vers le serveur de production..."

          # Variables de configuration production
          PRODUCTION_HOST="${{ secrets.PRODUCTION_HOST }}"
          PRODUCTION_USER="${{ secrets.PRODUCTION_USER }}"
          PRODUCTION_PATH="${{ secrets.PRODUCTION_PATH }}"  # Ex: /var/www/batistack.com
          PRODUCTION_URL="${{ secrets.PRODUCTION_URL }}"    # Ex: https://batistack.com
          DEPLOYMENT_ID="production-$(date +%s)"

          echo "üì° Connexion au serveur production : $PRODUCTION_USER@$PRODUCTION_HOST"

          # Transf√©rer le package
          echo "üì§ Transfert du package production..."
          scp -i ~/.ssh/production_key batistack-production.tar.gz $PRODUCTION_USER@$PRODUCTION_HOST:/tmp/

          # Ex√©cuter le d√©ploiement sur le serveur distant
          ssh -i ~/.ssh/production_key $PRODUCTION_USER@$PRODUCTION_HOST << 'EOF'
            set -e
            echo "üîÑ D√©ploiement en cours sur le serveur production..."

            # Variables locales
            PRODUCTION_PATH="${{ secrets.PRODUCTION_PATH }}"
            BACKUP_PATH="/tmp/batistack-backup-production-$(date +%s)"

            # Cr√©er une sauvegarde de l'ancienne version
            if [ -d "$PRODUCTION_PATH" ]; then
              echo "üíæ Sauvegarde de l'ancienne version production..."
              cp -r "$PRODUCTION_PATH" "$BACKUP_PATH"
            fi

            # Cr√©er le dossier de production s'il n'existe pas
            mkdir -p "$PRODUCTION_PATH"

            # Extraire le nouveau package
            echo "üì¶ Extraction du package production..."
            cd "$PRODUCTION_PATH"
            tar -xzf /tmp/batistack-production.tar.gz

            # Restaurer les dossiers de storage persistants
            if [ -d "$BACKUP_PATH/storage/app" ]; then
              cp -r "$BACKUP_PATH/storage/app" storage/
            fi
            if [ -d "$BACKUP_PATH/storage/logs" ]; then
              cp -r "$BACKUP_PATH/storage/logs" storage/
            fi

            # Copier le fichier .env sp√©cifique √† la production
            if [ -f ".env.production" ]; then
              echo '${{ secrets.PRODUCTION_ENV }}' > .env
              echo "üìÑ Fichier .env production configur√©"
            else
              echo "‚ö†Ô∏è Fichier .env.production non trouv√©, utilisation de .env.example"
              echo '${{ secrets.PRODUCTION_ENV }}' > .env
              # G√©n√©rer une nouvelle cl√© d'application
              php artisan key:generate --force
            fi

            # Installation des d√©pendances Composer
            echo "üì¶ Installation des d√©pendances production..."
            composer install --no-dev --optimize-autoloader --no-interaction

            # Migrations et cache
            echo "üóÑÔ∏è Migration de la base de donn√©es production..."
            php artisan migrate --force

            echo "üßπ Nettoyage et reconstruction du cache production..."
            php artisan cache:clear
            php artisan config:clear
            php artisan route:clear
            php artisan view:clear

            php artisan config:cache
            php artisan route:cache
            php artisan view:cache

            # Optimisations production
            php artisan optimize
            composer dump-autoload --optimize

            # Permissions (adaptez selon votre serveur web)
            echo "üîê Configuration des permissions production..."
            chown -R www-data:www-data storage bootstrap/cache
            chmod -R 775 storage bootstrap/cache

            # Red√©marrage des services (si n√©cessaire)
            echo "üîÑ Red√©marrage des services..."
            # sudo systemctl reload nginx
            # sudo systemctl restart php8.3-fpm

            # Nettoyage
            rm -f /tmp/batistack-production.tar.gz

            echo "‚úÖ D√©ploiement production termin√© avec succ√®s"
          EOF

          echo "üåê URL de production : $PRODUCTION_URL"
          echo "deployment-id=$DEPLOYMENT_ID" >> $GITHUB_OUTPUT
          echo "production-url=$PRODUCTION_URL" >> $GITHUB_OUTPUT

      - name: üß™ Post-deployment health check
        run: |
          echo "üß™ V√©rification de la sant√© de l'application production..."
          PRODUCTION_URL="${{ steps.deploy.outputs.production-url }}"

          # Attendre quelques secondes pour que le serveur se stabilise
          sleep 15

          # Test de connectivit√© avec retry
          for i in {1..3}; do
            if curl -f -s --max-time 30 "$PRODUCTION_URL" > /dev/null; then
              echo "‚úÖ Application production op√©rationnelle"
              echo "üìä Test de sant√© r√©ussi pour : $PRODUCTION_URL"
              break
            else
              echo "‚ö†Ô∏è Tentative $i/3 √©chou√©e, nouvelle tentative dans 10s..."
              sleep 10
            fi

            if [ $i -eq 3 ]; then
              echo "‚ùå Erreur lors du test de sant√© production"
              echo "üîç V√©rifiez manuellement l'URL : $PRODUCTION_URL"
              exit 1
            fi
          done

      - name: üßπ Cleanup SSH
        if: always()
        run: |
          echo "üßπ Nettoyage des cl√©s SSH production..."
          rm -f ~/.ssh/production_key
          rm -f batistack-production.tar.gz

  # ============================================================================
  # POST-DEPLOYMENT NOTIFICATIONS
  # ============================================================================
  notify-deployment:
    name: üì¢ Deployment notifications
    runs-on: ubuntu-latest
    if: always()
    needs: [deploy-staging, deploy-production]
    steps:
      - name: üì¢ Send Slack notification
        if: env.SLACK_WEBHOOK != ''
        run: |
          STAGING_STATUS="${{ needs.deploy-staging.result }}"
          PRODUCTION_STATUS="${{ needs.deploy-production.result }}"

          # D√©terminer le statut global
          if [[ "$STAGING_STATUS" == "success" && "$PRODUCTION_STATUS" == "success" ]]; then
            STATUS="‚úÖ Succ√®s"
            COLOR="good"
          elif [[ "$STAGING_STATUS" == "success" && "$PRODUCTION_STATUS" == "skipped" ]]; then
            STATUS="üü° Staging d√©ploy√©"
            COLOR="warning"
          else
            STATUS="‚ùå √âchec"
            COLOR="danger"
          fi

          # Construire le message Slack
          PAYLOAD=$(cat <<EOF
          {
            "attachments": [
              {
                "color": "$COLOR",
                "title": "üöÄ Rapport de d√©ploiement BatiStack",
                "fields": [
                  {
                    "title": "Statut global",
                    "value": "$STATUS",
                    "short": true
                  },
                  {
                    "title": "Branche",
                    "value": "${{ github.ref_name }}",
                    "short": true
                  },
                  {
                    "title": "Staging",
                    "value": "$STAGING_STATUS",
                    "short": true
                  },
                  {
                    "title": "Production",
                    "value": "$PRODUCTION_STATUS",
                    "short": true
                  },
                  {
                    "title": "Commit",
                    "value": "<https://github.com/${{ github.repository }}/commit/${{ github.sha }}|${{ github.sha }}>"
                  }
                ],
                "footer": "GitHub Actions",
                "ts": $(date +%s)
              }
            ]
          }
          EOF
          )

          curl -X POST -H 'Content-type: application/json' \
            --data "$PAYLOAD" \
            "$SLACK_WEBHOOK"

      - name: üìù Create deployment issue on failure
        if: failure()
        uses: actions/github-script@v7
        with:
          script: |
            const title = `üö® √âchec de d√©ploiement - ${context.ref}`;
            const body = `
            ## üö® √âchec de d√©ploiement d√©tect√©

            **Branche:** \`${context.ref}\`
            **Commit:** ${context.sha}
            **Workflow:** [${context.runId}](${context.payload.repository.html_url}/actions/runs/${context.runId})

            ### üìä Statuts des jobs
            - **Staging:** ${{ needs.deploy-staging.result }}
            - **Production:** ${{ needs.deploy-production.result }}

            ### üîç Actions recommand√©es
            1. V√©rifier les logs du workflow
            2. Analyser les erreurs de d√©ploiement
            3. Corriger les probl√®mes identifi√©s
            4. Relancer le d√©ploiement

            ### üîó Liens utiles
            - [Logs du workflow](${context.payload.repository.html_url}/actions/runs/${context.runId})
            - [Commit concern√©](${context.payload.repository.html_url}/commit/${context.sha})

            ---
            *Issue cr√©√©e automatiquement par le workflow de d√©ploiement*
            `;

            github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: title,
              body: body,
              labels: ['deployment', 'bug', 'urgent']
            });
