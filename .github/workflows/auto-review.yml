name: Auto Review

on:
  pull_request:
    types: [opened, synchronize, reopened]

permissions:
  contents: read
  pull-requests: write
  issues: write

jobs:
  auto-review:
    runs-on: ubuntu-latest
    if: github.event.pull_request.draft == false

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Auto Review
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GH_TOKEN }}
          script: |
            try {
              const { data: files } = await github.rest.pulls.listFiles({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: context.payload.pull_request.number
              });

              console.log(`Analyzing ${files.length} files in PR #${context.payload.pull_request.number}`);
              console.log('Files in PR:', files.map(f => f.filename));

              // V√©rifier si c'est l'auteur de la PR qui ex√©cute le workflow
              const prAuthor = context.payload.pull_request.user.login;
              const workflowActor = context.actor;
              const isOwnPR = prAuthor === workflowActor;

              console.log(`PR Author: ${prAuthor}, Workflow Actor: ${workflowActor}, Is Own PR: ${isOwnPR}`);

              // D√©tection am√©lior√©e des tests
              const hasTests = files.some(f => {
                const filename = f.filename.toLowerCase();
                return (
                  filename.includes('/tests/') ||
                  filename.includes('\\tests\\') ||
                  filename.includes('test.php') ||
                  filename.includes('_test.php') ||
                  filename.endsWith('test.php') ||
                  filename.includes('/test/') ||
                  filename.includes('\\test\\') ||
                  filename.includes('spec.php') ||
                  (filename.includes('test') && filename.endsWith('.php'))
                );
              });

              // D√©tection am√©lior√©e des migrations
              const hasMigrations = files.some(f => {
                const filename = f.filename.toLowerCase();
                return (
                  filename.includes('/migrations/') ||
                  filename.includes('\\migrations\\') ||
                  filename.includes('migration.php') ||
                  filename.includes('_migration.php') ||
                  (filename.includes('database/migrations') && filename.endsWith('.php')) ||
                  /\d{4}_\d{2}_\d{2}_\d{6}_.*\.php$/.test(filename) // Format Laravel migration
                );
              });

              // D√©tection am√©lior√©e des seeders
              const hasSeeder = files.some(f => {
                const filename = f.filename.toLowerCase();
                return (
                  filename.includes('/seeders/') ||
                  filename.includes('\\seeders\\') ||
                  filename.includes('seeder.php') ||
                  filename.includes('_seeder.php') ||
                  filename.endsWith('seeder.php') ||
                  (filename.includes('database/seeders') && filename.endsWith('.php'))
                );
              });

              // D√©tection des factories
              const hasFactories = files.some(f => {
                const filename = f.filename.toLowerCase();
                return (
                  filename.includes('/factories/') ||
                  filename.includes('\\factories\\') ||
                  filename.includes('factory.php') ||
                  filename.includes('_factory.php') ||
                  filename.endsWith('factory.php')
                );
              });

              // D√©tection des mod√®les
              const hasModels = files.some(f => {
                const filename = f.filename.toLowerCase();
                return (
                  filename.includes('/models/') ||
                  filename.includes('\\models\\') ||
                  filename.includes('app/models') ||
                  filename.includes('app\\models')
                );
              });

              // D√©tection des contr√¥leurs
              const hasControllers = files.some(f => {
                const filename = f.filename.toLowerCase();
                return (
                  filename.includes('/controllers/') ||
                  filename.includes('\\controllers\\') ||
                  filename.includes('controller.php')
                );
              });

              const hasPhpFiles = files.some(f => f.filename.endsWith('.php'));
              const hasLargeChanges = files.some(f => f.changes > 100);

              // Construire le message de review
              let reviewBody = '';
              let reviewEvent = 'COMMENT';
              let hasIssues = false;

              // V√©rification des tests pour les changements importants
              if (!hasTests && files.length > 3 && (hasModels || hasControllers) && hasPhpFiles) {
                reviewBody += '‚ö†Ô∏è **Tests manquants** : Cette PR modifie des mod√®les ou contr√¥leurs mais ne contient pas de tests correspondants.\n\n';
                hasIssues = true;
              }

              // V√©rification des migrations sans seeders
              if (hasMigrations && !hasSeeder && !hasFactories) {
                reviewBody += 'üí° **Suggestion** : Vous avez ajout√© des migrations. Pensez √† ajouter des seeders ou factories pour les donn√©es de test.\n\n';
              }

              // V√©rification des gros changements
              if (hasLargeChanges) {
                reviewBody += 'üìè **Gros changements d√©tect√©s** : Certains fichiers ont plus de 100 lignes modifi√©es. Assurez-vous que la PR reste focalis√©e.\n\n';
              }

              // Statistiques d√©taill√©es
              const phpFiles = files.filter(f => f.filename.endsWith('.php')).length;
              const totalAdditions = files.reduce((sum, f) => sum + f.additions, 0);
              const totalDeletions = files.reduce((sum, f) => sum + f.deletions, 0);

              reviewBody += `üìä **Statistiques de la PR** :\n`;
              reviewBody += `- ${files.length} fichier(s) modifi√©(s)\n`;
              reviewBody += `- ${phpFiles} fichier(s) PHP\n`;
              reviewBody += `- +${totalAdditions} / -${totalDeletions} lignes\n\n`;

              reviewBody += `üîç **Analyse du contenu** :\n`;
              reviewBody += `- Tests inclus : ${hasTests ? '‚úÖ' : '‚ùå'}\n`;
              reviewBody += `- Migrations : ${hasMigrations ? '‚úÖ' : '‚ùå'}\n`;
              reviewBody += `- Seeders : ${hasSeeder ? '‚úÖ' : '‚ùå'}\n`;
              reviewBody += `- Factories : ${hasFactories ? '‚úÖ' : '‚ùå'}\n`;
              reviewBody += `- Mod√®les : ${hasModels ? '‚úÖ' : '‚ùå'}\n`;
              reviewBody += `- Contr√¥leurs : ${hasControllers ? '‚úÖ' : '‚ùå'}\n\n`;

              // Debug: Lister les fichiers pour diagnostic
              if (files.length <= 10) {
                reviewBody += `üìÅ **Fichiers modifi√©s** :\n`;
                files.forEach(f => {
                  reviewBody += `- \`${f.filename}\` (+${f.additions}/-${f.deletions})\n`;
                });
                reviewBody += '\n';
              }

              // Conseils g√©n√©raux
              reviewBody += `üí° **Conseils** :\n`;
              reviewBody += `- V√©rifiez que votre code suit les standards PSR-12\n`;
              reviewBody += `- Assurez-vous que les tests passent localement\n`;
              reviewBody += `- Documentez les changements importants\n`;

              // D√©terminer le type de review et le message
              if (hasIssues && !isOwnPR && files.length > 10) {
                reviewEvent = 'REQUEST_CHANGES';
                reviewBody = 'üîç **Review automatique - Action requise**\n\n' + reviewBody;
                reviewBody += '\n‚ùå **Des am√©liorations sont n√©cessaires avant la fusion.**';
              } else if (hasIssues) {
                reviewEvent = 'COMMENT';
                reviewBody = 'ü§ñ **Review automatique - Suggestions**\n\n' + reviewBody;
                if (isOwnPR) {
                  reviewBody += '\nüí° **Note** : Comme c\'est votre propre PR, voici quelques suggestions d\'am√©lioration.';
                }
              } else {
                reviewEvent = 'COMMENT';
                reviewBody = 'ü§ñ **Review automatique - Tout semble bon !**\n\n' + reviewBody;
                reviewBody += '\n‚úÖ Aucun probl√®me majeur d√©tect√©. Bon travail !';
              }

              // Si c'est sa propre PR et qu'il y a des probl√®mes, cr√©er un commentaire au lieu d'une review
              if (isOwnPR && hasIssues && files.length > 10) {
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.payload.pull_request.number,
                  body: `ü§ñ **Auto-analyse de votre PR**\n\n${reviewBody}\n\n‚ö†Ô∏è **Attention** : Cette PR n√©cessite des am√©liorations avant d'√™tre fusionn√©e.`
                });
                console.log('Comment created instead of review for own PR');
              } else {
                // Cr√©er la review normale
                await github.rest.pulls.createReview({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: context.payload.pull_request.number,
                  body: reviewBody,
                  event: reviewEvent
                });
                console.log(`Review created with event: ${reviewEvent}`);
              }

              // Ajouter des labels automatiques bas√©s sur l'analyse
              const labelsToAdd = [];

              if (!hasTests && hasPhpFiles && (hasModels || hasControllers)) {
                labelsToAdd.push('needs-tests');
              }

              if (hasLargeChanges) {
                labelsToAdd.push('large-changes');
              }

              if (hasMigrations) {
                labelsToAdd.push('database-changes');
              }

              if (hasModels) {
                labelsToAdd.push('models');
              }

              if (hasControllers) {
                labelsToAdd.push('controllers');
              }

              if (labelsToAdd.length > 0) {
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.payload.pull_request.number,
                  labels: labelsToAdd
                });
                console.log(`Labels added: ${labelsToAdd.join(', ')}`);
              }

            } catch (error) {
              console.error('Error during auto-review:', error);

              // Cr√©er un commentaire d'erreur au lieu d'√©chouer
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.pull_request.number,
                body: `ü§ñ **Erreur lors de la review automatique**\n\nUne erreur s'est produite lors de l'analyse automatique : ${error.message}\n\n*Cette erreur a √©t√© automatiquement rapport√©e.*`
              });
            }
