name: Auto Review

on:
  pull_request:
    types: [opened, synchronize, reopened]

permissions:
  contents: read
  pull-requests: write
  issues: write

jobs:
  auto-review:
    runs-on: ubuntu-latest
    if: github.event.pull_request.draft == false

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Auto Review
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GH_TOKEN }}
          script: |
            try {
              const { data: files } = await github.rest.pulls.listFiles({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: context.payload.pull_request.number
              });

              console.log(`Analyzing ${files.length} files in PR #${context.payload.pull_request.number}`);
              console.log('Files in PR:', files.map(f => f.filename));

              // VÃ©rifier si c'est l'auteur de la PR qui exÃ©cute le workflow
              const prAuthor = context.payload.pull_request.user.login;
              const workflowActor = context.actor;
              const isOwnPR = prAuthor === workflowActor;

              console.log(`PR Author: ${prAuthor}, Workflow Actor: ${workflowActor}, Is Own PR: ${isOwnPR}`);

              // DÃ©tection amÃ©liorÃ©e des tests
              const hasTests = files.some(f => {
                const filename = f.filename.toLowerCase();
                return (
                  filename.includes('/tests/') ||
                  filename.includes('\\tests\\') ||
                  filename.includes('test.php') ||
                  filename.includes('_test.php') ||
                  filename.endsWith('test.php') ||
                  filename.includes('/test/') ||
                  filename.includes('\\test\\') ||
                  filename.includes('spec.php') ||
                  (filename.includes('test') && filename.endsWith('.php'))
                );
              });

              // DÃ©tection amÃ©liorÃ©e des migrations
              const hasMigrations = files.some(f => {
                const filename = f.filename.toLowerCase();
                return (
                  filename.includes('/migrations/') ||
                  filename.includes('\\migrations\\') ||
                  filename.includes('migration.php') ||
                  filename.includes('_migration.php') ||
                  (filename.includes('database/migrations') && filename.endsWith('.php')) ||
                  /\d{4}_\d{2}_\d{2}_\d{6}_.*\.php$/.test(filename) // Format Laravel migration
                );
              });

              // DÃ©tection amÃ©liorÃ©e des seeders
              const hasSeeder = files.some(f => {
                const filename = f.filename.toLowerCase();
                return (
                  filename.includes('/seeders/') ||
                  filename.includes('\\seeders\\') ||
                  filename.includes('seeder.php') ||
                  filename.includes('_seeder.php') ||
                  filename.endsWith('seeder.php') ||
                  (filename.includes('database/seeders') && filename.endsWith('.php'))
                );
              });

              // DÃ©tection des factories
              const hasFactories = files.some(f => {
                const filename = f.filename.toLowerCase();
                return (
                  filename.includes('/factories/') ||
                  filename.includes('\\factories\\') ||
                  filename.includes('factory.php') ||
                  filename.includes('_factory.php') ||
                  filename.endsWith('factory.php')
                );
              });

              // DÃ©tection des modÃ¨les
              const hasModels = files.some(f => {
                const filename = f.filename.toLowerCase();
                return (
                  filename.includes('/models/') ||
                  filename.includes('\\models\\') ||
                  filename.includes('app/models') ||
                  filename.includes('app\\models')
                );
              });

              // DÃ©tection des contrÃ´leurs
              const hasControllers = files.some(f => {
                const filename = f.filename.toLowerCase();
                return (
                  filename.includes('/controllers/') ||
                  filename.includes('\\controllers\\') ||
                  filename.includes('controller.php')
                );
              });

              const hasPhpFiles = files.some(f => f.filename.endsWith('.php'));
              const hasLargeChanges = files.some(f => f.changes > 100);

              // Construire le message de review
              let reviewBody = '';
              let reviewEvent = 'COMMENT';
              let hasIssues = false;

              // VÃ©rification des tests pour les changements importants
              if (!hasTests && files.length > 3 && (hasModels || hasControllers) && hasPhpFiles) {
                reviewBody += 'âš ï¸ **Tests manquants** : Cette PR modifie des modÃ¨les ou contrÃ´leurs mais ne contient pas de tests correspondants.\n\n';
                hasIssues = true;
              }

              // VÃ©rification des migrations sans seeders
              if (hasMigrations && !hasSeeder && !hasFactories) {
                reviewBody += 'ğŸ’¡ **Suggestion** : Vous avez ajoutÃ© des migrations. Pensez Ã  ajouter des seeders ou factories pour les donnÃ©es de test.\n\n';
              }

              // VÃ©rification des gros changements
              if (hasLargeChanges) {
                reviewBody += 'ğŸ“ **Gros changements dÃ©tectÃ©s** : Certains fichiers ont plus de 100 lignes modifiÃ©es. Assurez-vous que la PR reste focalisÃ©e.\n\n';
              }

              // Statistiques dÃ©taillÃ©es
              const phpFiles = files.filter(f => f.filename.endsWith('.php')).length;
              const totalAdditions = files.reduce((sum, f) => sum + f.additions, 0);
              const totalDeletions = files.reduce((sum, f) => sum + f.deletions, 0);

              reviewBody += `ğŸ“Š **Statistiques de la PR** :\n`;
              reviewBody += `- ${files.length} fichier(s) modifiÃ©(s)\n`;
              reviewBody += `- ${phpFiles} fichier(s) PHP\n`;
              reviewBody += `- +${totalAdditions} / -${totalDeletions} lignes\n\n`;

              reviewBody += `ğŸ” **Analyse du contenu** :\n`;
              reviewBody += `- Tests inclus : ${hasTests ? 'âœ…' : 'âŒ'}\n`;
              reviewBody += `- Migrations : ${hasMigrations ? 'âœ…' : 'âŒ'}\n`;
              reviewBody += `- Seeders : ${hasSeeder ? 'âœ…' : 'âŒ'}\n`;
              reviewBody += `- Factories : ${hasFactories ? 'âœ…' : 'âŒ'}\n`;
              reviewBody += `- ModÃ¨les : ${hasModels ? 'âœ…' : 'âŒ'}\n`;
              reviewBody += `- ContrÃ´leurs : ${hasControllers ? 'âœ…' : 'âŒ'}\n\n`;

              // Debug: Lister les fichiers pour diagnostic
              if (files.length <= 10) {
                reviewBody += `ğŸ“ **Fichiers modifiÃ©s** :\n`;
                files.forEach(f => {
                  reviewBody += `- \`${f.filename}\` (+${f.additions}/-${f.deletions})\n`;
                });
                reviewBody += '\n';
              }

              // Conseils gÃ©nÃ©raux
              reviewBody += `ğŸ’¡ **Conseils** :\n`;
              reviewBody += `- VÃ©rifiez que votre code suit les standards PSR-12\n`;
              reviewBody += `- Assurez-vous que les tests passent localement\n`;
              reviewBody += `- Documentez les changements importants\n`;

              // DÃ©terminer le type de review et le message
              if (hasIssues && !isOwnPR && files.length > 10) {
                reviewEvent = 'REQUEST_CHANGES';
                reviewBody = 'ğŸ” **Review automatique - Action requise**\n\n' + reviewBody;
                reviewBody += '\nâŒ **Des amÃ©liorations sont nÃ©cessaires avant la fusion.**';
              } else if (hasIssues) {
                reviewEvent = 'COMMENT';
                reviewBody = 'ğŸ¤– **Review automatique - Suggestions**\n\n' + reviewBody;
                if (isOwnPR) {
                  reviewBody += '\nğŸ’¡ **Note** : Comme c\'est votre propre PR, voici quelques suggestions d\'amÃ©lioration.';
                }
              } else {
                reviewEvent = 'COMMENT';
                reviewBody = 'ğŸ¤– **Review automatique - Tout semble bon !**\n\n' + reviewBody;
                reviewBody += '\nâœ… Aucun problÃ¨me majeur dÃ©tectÃ©. Bon travail !';
              }

              // Si c'est sa propre PR et qu'il y a des problÃ¨mes, crÃ©er un commentaire au lieu d'une review
              if (isOwnPR && hasIssues && files.length > 10) {
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.payload.pull_request.number,
                  body: `ğŸ¤– **Auto-analyse de votre PR**\n\n${reviewBody}\n\nâš ï¸ **Attention** : Cette PR nÃ©cessite des amÃ©liorations avant d'Ãªtre fusionnÃ©e.`
                });
                console.log('Comment created instead of review for own PR');
              } else {
                // CrÃ©er la review normale
                await github.rest.pulls.createReview({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: context.payload.pull_request.number,
                  body: reviewBody,
                  event: reviewEvent
                });
                console.log(`Review created with event: ${reviewEvent}`);
              }

              // Ajouter des labels automatiques basÃ©s sur l'analyse
              const labelsToAdd = [];

              if (!hasTests && hasPhpFiles && (hasModels || hasControllers)) {
                labelsToAdd.push('needs-tests');
              }

              if (hasLargeChanges) {
                labelsToAdd.push('large-changes');
              }

              if (hasMigrations) {
                labelsToAdd.push('database-changes');
              }

              if (hasModels) {
                labelsToAdd.push('models');
              }

              if (hasControllers) {
                labelsToAdd.push('controllers');
              }

              if (labelsToAdd.length > 0) {
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.payload.pull_request.number,
                  labels: labelsToAdd
                });
                console.log(`Labels added: ${labelsToAdd.join(', ')}`);
              }

            } catch (error) {
              console.error('Error during auto-review:', error);

              // CrÃ©er un commentaire d'erreur au lieu d'Ã©chouer
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.pull_request.number,
                body: `ğŸ¤– **Erreur lors de la review automatique**\n\nUne erreur s'est produite lors de l'analyse automatique : ${error.message}\n\n*Cette erreur a Ã©tÃ© automatiquement rapportÃ©e.*`
              });
            }
