name: Auto Review

on:
  pull_request:
    types: [opened, synchronize, reopened]

permissions:
  contents: read
  pull-requests: write
  issues: write

jobs:
  auto-review:
    runs-on: ubuntu-latest
    if: github.event.pull_request.draft == false

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Auto Review
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GH_TOKEN }}
          script: |
            try {
              const { data: files } = await github.rest.pulls.listFiles({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: context.payload.pull_request.number
              });

              console.log(`Analyzing ${files.length} files in PR #${context.payload.pull_request.number}`);

              // V√©rifier si c'est l'auteur de la PR qui ex√©cute le workflow
              const prAuthor = context.payload.pull_request.user.login;
              const workflowActor = context.actor;
              const isOwnPR = prAuthor === workflowActor;

              console.log(`PR Author: ${prAuthor}, Workflow Actor: ${workflowActor}, Is Own PR: ${isOwnPR}`);

              // V√©rifications automatiques
              const hasTests = files.some(f =>
                f.filename.includes('test') ||
                f.filename.includes('Test') ||
                f.filename.includes('spec')
              );

              const hasMigrations = files.some(f =>
                f.filename.includes('migration') ||
                f.filename.includes('Migration')
              );

              const hasSeeder = files.some(f =>
                f.filename.includes('seeder') ||
                f.filename.includes('Seeder')
              );

              const hasPhpFiles = files.some(f => f.filename.endsWith('.php'));
              const hasLargeChanges = files.some(f => f.changes > 100);

              // Construire le message de review
              let reviewBody = '';
              let reviewEvent = 'COMMENT'; // Par d√©faut, toujours COMMENT
              let hasIssues = false;

              // V√©rification des tests
              if (!hasTests && files.length > 5 && hasPhpFiles) {
                reviewBody += '‚ö†Ô∏è **Tests manquants** : Cette PR semble importante mais ne contient pas de tests.\n\n';
                hasIssues = true;
              }

              // V√©rification des migrations sans seeders
              if (hasMigrations && !hasSeeder) {
                reviewBody += 'üí° **Suggestion** : Vous avez ajout√© des migrations. Pensez √† ajouter des seeders si n√©cessaire.\n\n';
              }

              // V√©rification des gros changements
              if (hasLargeChanges) {
                reviewBody += 'üìè **Gros changements d√©tect√©s** : Certains fichiers ont plus de 100 lignes modifi√©es. Assurez-vous que la PR reste focalis√©e.\n\n';
              }

              // Statistiques
              const phpFiles = files.filter(f => f.filename.endsWith('.php')).length;
              const totalAdditions = files.reduce((sum, f) => sum + f.additions, 0);
              const totalDeletions = files.reduce((sum, f) => sum + f.deletions, 0);

              reviewBody += `üìä **Statistiques de la PR** :\n`;
              reviewBody += `- ${files.length} fichier(s) modifi√©(s)\n`;
              reviewBody += `- ${phpFiles} fichier(s) PHP\n`;
              reviewBody += `- +${totalAdditions} / -${totalDeletions} lignes\n`;
              reviewBody += `- Tests inclus : ${hasTests ? '‚úÖ' : '‚ùå'}\n`;
              reviewBody += `- Migrations : ${hasMigrations ? '‚úÖ' : '‚ùå'}\n\n`;

              // Conseils g√©n√©raux
              reviewBody += `üí° **Conseils** :\n`;
              reviewBody += `- V√©rifiez que votre code suit les standards PSR-12\n`;
              reviewBody += `- Assurez-vous que les tests passent localement\n`;
              reviewBody += `- Documentez les changements importants\n`;

              // D√©terminer le type de review et le message
              if (hasIssues && !isOwnPR && files.length > 10) {
                // Seulement REQUEST_CHANGES si ce n'est pas sa propre PR et qu'il y a de vrais probl√®mes
                reviewEvent = 'REQUEST_CHANGES';
                reviewBody = 'üîç **Review automatique - Action requise**\n\n' + reviewBody;
                reviewBody += '\n‚ùå **Des am√©liorations sont n√©cessaires avant la fusion.**';
              } else if (hasIssues) {
                // Sinon, juste un commentaire avec suggestions
                reviewEvent = 'COMMENT';
                reviewBody = 'ü§ñ **Review automatique - Suggestions**\n\n' + reviewBody;
                if (isOwnPR) {
                  reviewBody += '\nüí° **Note** : Comme c\'est votre propre PR, voici quelques suggestions d\'am√©lioration.';
                }
              } else {
                reviewEvent = 'COMMENT';
                reviewBody = 'ü§ñ **Review automatique - Tout semble bon !**\n\n' + reviewBody;
                reviewBody += '\n‚úÖ Aucun probl√®me majeur d√©tect√©. Bon travail !';
              }

              // Si c'est sa propre PR et qu'il y a des probl√®mes, cr√©er un commentaire au lieu d'une review
              if (isOwnPR && hasIssues && files.length > 10) {
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.payload.pull_request.number,
                  body: `ü§ñ **Auto-analyse de votre PR**\n\n${reviewBody}\n\n‚ö†Ô∏è **Attention** : Cette PR n√©cessite des am√©liorations avant d'√™tre fusionn√©e.`
                });
                console.log('Comment created instead of review for own PR');
              } else {
                // Cr√©er la review normale
                await github.rest.pulls.createReview({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: context.payload.pull_request.number,
                  body: reviewBody,
                  event: reviewEvent
                });
                console.log(`Review created with event: ${reviewEvent}`);
              }

              // Ajouter des labels automatiques bas√©s sur l'analyse
              const labelsToAdd = [];

              if (!hasTests && hasPhpFiles) {
                labelsToAdd.push('needs-tests');
              }

              if (hasLargeChanges) {
                labelsToAdd.push('large-changes');
              }

              if (hasMigrations) {
                labelsToAdd.push('database-changes');
              }

              if (labelsToAdd.length > 0) {
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.payload.pull_request.number,
                  labels: labelsToAdd
                });
                console.log(`Labels added: ${labelsToAdd.join(', ')}`);
              }

            } catch (error) {
              console.error('Error during auto-review:', error);

              // Cr√©er un commentaire d'erreur au lieu d'√©chouer
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.pull_request.number,
                body: `ü§ñ **Erreur lors de la review automatique**\n\nUne erreur s'est produite lors de l'analyse automatique : ${error.message}\n\n*Cette erreur a √©t√© automatiquement rapport√©e.*`
              });
            }
